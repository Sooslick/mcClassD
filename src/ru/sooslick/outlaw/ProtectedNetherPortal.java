package ru.sooslick.outlaw;

import org.bukkit.Location;
import org.bukkit.block.Block;
import org.bukkit.block.BlockState;
import org.bukkit.entity.Entity;
import ru.sooslick.outlaw.roles.Outlaw;
import ru.sooslick.outlaw.util.LoggerUtil;
import ru.sooslick.outlaw.util.WorldUtil;

import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Protected Nether Portal.
 * Stores all created portals in the Nether and blocks that belong to certain portal.
 * Used to protect portals from being destroyed if denyNetherTravelling option is enabled
 */
public class ProtectedNetherPortal {
    private static final String DEBUG_CREATE = "Tracked new nether portal %s";
    private static final String DEBUG_FIND = "Requesting tracked portal, result is %s";

    private static final List<ProtectedNetherPortal> trackedPortals = new LinkedList<>();

    private static boolean linkNextPortalToVictim = false;

    private final List<Block> netherPortalBlocks;
    private final String baseLocation;

    /**
     * Save and track the created portal
     * @param blockStates list of blocks belonging to the portal, generated by PortalCreateEvent
     * @param entity entity who triggers the event
     * @return tracked portal instance
     */
    public static ProtectedNetherPortal trackNewPortal(List<BlockState> blockStates, Entity entity) {
        // map blockStates to Nlocks
        List<Block> blocks = blockStates.stream().map(BlockState::getBlock).collect(Collectors.toList());
        // find existing tracked portals
        Set<ProtectedNetherPortal> existing = blocks.stream()
                .map(b -> findExistingPortal(b.getLocation()))
                .filter(Objects::nonNull)
                .collect(Collectors.toSet());
        // remove old overlapping instances
        trackedPortals.removeAll(existing);
        // create new instance
        ProtectedNetherPortal createdPortal = new ProtectedNetherPortal(blocks);
        trackedPortals.add(createdPortal);
        LoggerUtil.debug(String.format(DEBUG_CREATE, createdPortal));
        // check if victim travels to nether
        if (linkNextPortalToVictim) {
            Outlaw o = Engine.getInstance().getOutlaw();
            if (o.getEntity().equals(entity))
                o.setTrackedNetherPortal(createdPortal);
            linkNextPortalToVictim = false;
        }
        return createdPortal;
    }

    /**
     * Check if any portal exists on the location
     * @param where location to check
     * @return tracked portal instance or null if not exist
     */
    public static ProtectedNetherPortal findExistingPortal(Location where) {
        ProtectedNetherPortal portal = trackedPortals.stream()
                .filter(p -> p.isMatchingBlock(where.getBlock()))
                .findFirst()
                .orElse(null);
        LoggerUtil.debug(String.format(DEBUG_FIND, portal));
        if (portal == null)
            // bcs portal event triggered BEFORE create event
            linkNextPortalToVictim = true;
        return portal;
    }

    /**
     * Stop tracking portals
     */
    public static void clear() {
        linkNextPortalToVictim = false;
        trackedPortals.clear();
    }

    private ProtectedNetherPortal(List<Block> blocks) {
        netherPortalBlocks = blocks;
        baseLocation = blocks.isEmpty() ? "unknown" : WorldUtil.formatLocation(blocks.get(0).getLocation());
    }

    /**
     * Check if the block is belonging to the portal
     * @param where block to check
     * @return true if belonging, false otherwise
     */
    public boolean isMatchingBlock(Block where) {
        return netherPortalBlocks.contains(where);
    }

    /**
     * Format portal location
     * @return string value
     */
    public String toString() {
        return baseLocation;
    }
}
